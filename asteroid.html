<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8"/>
    <title>Project Perigee – 3D Impact Viewer</title>
    <meta name="viewport" content="width=device-width,initial-scale=1"/>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background: #000;
        }

        #globeViz {
            position: relative;
            width: 100%;
            height: 100vh;
            z-index: 0;
            overflow: hidden;
        }
        #globeViz > canvas, #globeViz > div, #globeViz > svg {
            width: 100% !important;
            height: 100% !important;
            display: block;
        }
        /* In case Globe.gl nests deeper wrappers, force fill */
        #globeViz * { box-sizing: border-box; }

        /* Split layout toggled on the wrapper to avoid body overrides */
        #viewRoot.view { width: 100vw; height: 100vh; }
        #viewRoot.split {
            display: grid;
            grid-template-columns: minmax(0, 2fr) minmax(280px, 1fr);
            grid-template-rows: 100vh;
        }
        #viewRoot.split #globeViz { width: 100%; height: 100vh; grid-area: 1 / 1 / 2 / 2; }
        #statsPanel {
            display: none;
            background: linear-gradient(180deg, #121826, #1a2333);
            color: #e6eefc;
            border-left: 1px solid #22304a;
            /* generous bottom padding so content never sits under sticky footer */
            padding: 14px 14px 140px;
            overflow: auto;
            font-family: ui-sans-serif, -apple-system, Segoe UI, Roboto, Helvetica, Arial;
            position: relative;
            z-index: 1;
        }
        #statsPanel h2 { margin: 6px 0 10px; font-size: 18px; }
        #statsPanel .meta { color: #9fb3c8; font-size: 12px; margin-bottom: 8px; }
        #statsPanel .item { background: #0f1420; border: 1px solid #22304a; border-radius: 10px; padding: 10px; margin: 8px 0; }
        #statsPanel .row { display: flex; justify-content: space-between; gap: 8px; }
        #statsPanel .t { color: #9fb3c8; font-size: 12px; }
        #statsPanel .v { font-weight: 700; }
        #viewRoot.split #statsPanel { display: block; height: 100vh; grid-area: 1 / 2 / 2 / 3; }
        /* KPI info badge */
        #statsPanel .with-info { display: inline-flex; align-items: center; gap: 6px; }
        #statsPanel .info-badge {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            width: 16px; height: 16px;
            border: 1px solid #3a4a6a;
            border-radius: 50%;
            font-size: 10px;
            line-height: 1;
            color: #9fb3c8;
            cursor: help;
            user-select: none;
        }
        #statsPanel .info-badge:hover { background: #1e2a40; }
        /* Any titled element should show help cursor for discoverability */
        #statsPanel [title] { cursor: help; }
        /* Sticky footer for action button */
        #statsPanel .footer {
            position: sticky;
            bottom: 0;
            background: linear-gradient(180deg, rgba(18,24,38,0.0), #121826 35%);
            padding: 12px 0 16px;
            margin: 6px 0 0;
            border-top: 1px solid #22304a;
            display: flex;
            justify-content: center;
            z-index: 2;
        }
        #statsPanel .footer button {
            width: 100%;
            max-width: 260px;
        }
    </style>
</head>
<body>
<div id="viewRoot" class="view">
  <div id="globeViz"></div>
  <div id="statsPanel"></div>
  
</div>

<script type="importmap">
    {
      "imports": {
        "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
        "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
      }
    }
</script>
<script src="//cdn.jsdelivr.net/npm/globe.gl"></script>
<script type="module">
    import * as THREE from 'three';
    import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';

    const ETALON = 100;
    const EARTH_CENTER = new THREE.Vector3(0, 0, 0);
    const N = 1;
    let rings = [];
    let ringsDirty = false;
    // Static burn polygons (GeoJSON features)
    let burnPolys = [];
    let burnPolysDirty = false;
    // Hover circle overlay (single line loop)
    let hoverCircle = null;
    // Persistent crater rim overlay
    let craterRim = null;
    let plannedRingKm = [];
    let asteroidTemplate = null;
    const clock = new THREE.Clock();
    let rafId = null;
    let asteroids = [];
    let followTarget = null;
    let currentImpact = null;
    // Prefetch state to warm API data before impact UI needs it
    let prefetchState = { lat: null, lon: null, isOceanP: null, summaryP: null, popPromises: new Map() };
    // Known impact info (from index page)
    let impactLatLng = null;      // { lat, lng }
    let impactTargetVec = null;   // THREE.Vector3 on the sphere (radius ETALON)
    // Shake & sound state
    let shake = { base: 3.0, active: 0, start: 0, duration: 0, until: 0, freq: { x: 19, y: 27, z: 33 } };
    let sound = { enabled: true, impactUrl: null, impactAudio: null };
    let impactDone = false;
    // Post-impact zoom state
    let zoomTransition = { active: false, start: 0, dur: 1200, fromPos: null, toPos: null, fromFov: 85, toFov: 38, aim: null };

    // Extended capitals fallback (selected world capitals; not exhaustive, but large)
    const capitalsExtended = [
        // Europe
        { name: 'Amsterdam', lat: 52.3676, lng: 4.9041, pop: 872000 },
        { name: 'Andorra la Vella', lat: 42.5063, lng: 1.5218, pop: 22600 },
        { name: 'Athens', lat: 37.9838, lng: 23.7275, pop: 3090000 },
        { name: 'Belgrade', lat: 44.7866, lng: 20.4489, pop: 1376000 },
        { name: 'Berlin', lat: 52.5200, lng: 13.4050, pop: 3769000 },
        { name: 'Bern', lat: 46.9480, lng: 7.4474, pop: 133000 },
        { name: 'Bratislava', lat: 48.1486, lng: 17.1077, pop: 430000 },
        { name: 'Brussels', lat: 50.8503, lng: 4.3517, pop: 1210000 },
        { name: 'Bucharest', lat: 44.4268, lng: 26.1025, pop: 1883000 },
        { name: 'Budapest', lat: 47.4979, lng: 19.0402, pop: 1750000 },
        { name: 'Chisinau', lat: 47.0105, lng: 28.8638, pop: 639000 },
        { name: 'Copenhagen', lat: 55.6761, lng: 12.5683, pop: 794000 },
        { name: 'Dublin', lat: 53.3498, lng: -6.2603, pop: 553000 },
        { name: 'Helsinki', lat: 60.1699, lng: 24.9384, pop: 655000 },
        { name: 'Kiev', lat: 50.4501, lng: 30.5234, pop: 2967000 },
        { name: 'Lisbon', lat: 38.7223, lng: -9.1393, pop: 504000 },
        { name: 'Ljubljana', lat: 46.0569, lng: 14.5058, pop: 295000 },
        { name: 'London', lat: 51.5074, lng: -0.1278, pop: 9000000 },
        { name: 'Luxembourg', lat: 49.6116, lng: 6.1319, pop: 122000 },
        { name: 'Madrid', lat: 40.4168, lng: -3.7038, pop: 3223000 },
        { name: 'Minsk', lat: 53.9045, lng: 27.5615, pop: 2000000 },
        { name: 'Monaco', lat: 43.7384, lng: 7.4246, pop: 39000 },
        { name: 'Moscow', lat: 55.7558, lng: 37.6173, pop: 12500000 },
        { name: 'Oslo', lat: 59.9139, lng: 10.7522, pop: 681000 },
        { name: 'Paris', lat: 48.8566, lng: 2.3522, pop: 2148000 },
        { name: 'Podgorica', lat: 42.4304, lng: 19.2594, pop: 186000 },
        { name: 'Prague', lat: 50.0755, lng: 14.4378, pop: 1309000 },
        { name: 'Reykjavik', lat: 64.1466, lng: -21.9426, pop: 131000 },
        { name: 'Riga', lat: 56.9496, lng: 24.1052, pop: 632000 },
        { name: 'Rome', lat: 41.9028, lng: 12.4964, pop: 2873000 },
        { name: 'San Marino', lat: 43.9424, lng: 12.4578, pop: 28000 },
        { name: 'Sarajevo', lat: 43.8563, lng: 18.4131, pop: 344000 },
        { name: 'Skopje', lat: 41.9981, lng: 21.4254, pop: 546000 },
        { name: 'Sofia', lat: 42.6977, lng: 23.3219, pop: 1246000 },
        { name: 'Stockholm', lat: 59.3293, lng: 18.0686, pop: 975000 },
        { name: 'Tallinn', lat: 59.4370, lng: 24.7536, pop: 426000 },
        { name: 'Tirana', lat: 41.3275, lng: 19.8189, pop: 421000 },
        { name: 'Vaduz', lat: 47.141, lng: 9.521, pop: 6000 },
        { name: 'Valletta', lat: 35.8989, lng: 14.5146, pop: 6000 },
        { name: 'Vienna', lat: 48.2082, lng: 16.3738, pop: 1897000 },
        { name: 'Vilnius', lat: 54.6872, lng: 25.2797, pop: 588000 },
        { name: 'Warsaw', lat: 52.2297, lng: 21.0122, pop: 1790000 },
        { name: 'Zagreb', lat: 45.8150, lng: 15.9819, pop: 806000 },
        // Americas
        { name: 'Washington', lat: 38.9072, lng: -77.0369, pop: 705000 },
        { name: 'Ottawa', lat: 45.4215, lng: -75.6972, pop: 994000 },
        { name: 'Mexico City', lat: 19.4326, lng: -99.1332, pop: 8855000 },
        { name: 'Guatemala City', lat: 14.6349, lng: -90.5069, pop: 995000 },
        { name: 'Belmopan', lat: 17.2510, lng: -88.7590, pop: 17000 },
        { name: 'San Salvador', lat: 13.6929, lng: -89.2182, pop: 567000 },
        { name: 'Tegucigalpa', lat: 14.0723, lng: -87.1921, pop: 1200000 },
        { name: 'Managua', lat: 12.1140, lng: -86.2362, pop: 1026000 },
        { name: 'San José', lat: 9.9281, lng: -84.0907, pop: 333000 },
        { name: 'Panama City', lat: 8.9824, lng: -79.5199, pop: 880000 },
        { name: 'Havana', lat: 23.1136, lng: -82.3666, pop: 2130000 },
        { name: 'Nassau', lat: 25.0478, lng: -77.3554, pop: 275000 },
        { name: 'Kingston', lat: 17.9712, lng: -76.7920, pop: 580000 },
        { name: 'Santo Domingo', lat: 18.4861, lng: -69.9312, pop: 965000 },
        { name: 'Port-au-Prince', lat: 18.5944, lng: -72.3074, pop: 987000 },
        { name: 'Port of Spain', lat: 10.6600, lng: -61.5080, pop: 370000 },
        { name: 'Bridgetown', lat: 13.0975, lng: -59.6167, pop: 110000 },
        { name: 'Castries', lat: 14.0101, lng: -60.9875, pop: 20000 },
        { name: 'St. John’s', lat: 17.1274, lng: -61.8468, pop: 22000 },
        { name: 'Roseau', lat: 15.3010, lng: -61.3870, pop: 14000 },
        { name: 'Kralendijk', lat: 12.1444, lng: -68.2656, pop: 20000 },
        { name: 'Oranjestad', lat: 12.5092, lng: -70.0086, pop: 35000 },
        { name: 'Willemstad', lat: 12.1224, lng: -68.8825, pop: 150000 },
        { name: 'Bogotá', lat: 4.7110, lng: -74.0721, pop: 7744000 },
        { name: 'Quito', lat: -0.1807, lng: -78.4678, pop: 2011000 },
        { name: 'Lima', lat: -12.0464, lng: -77.0428, pop: 9675000 },
        { name: 'La Paz', lat: -16.4897, lng: -68.1193, pop: 757000 },
        { name: 'Sucre', lat: -19.0196, lng: -65.2619, pop: 260000 },
        { name: 'Santiago', lat: -33.4489, lng: -70.6693, pop: 5744000 },
        { name: 'Buenos Aires', lat: -34.6037, lng: -58.3816, pop: 2890000 },
        { name: 'Montevideo', lat: -34.9011, lng: -56.1645, pop: 1380000 },
        { name: 'Asunción', lat: -25.2637, lng: -57.5759, pop: 524000 },
        { name: 'Brasília', lat: -15.7939, lng: -47.8828, pop: 3015000 },
        { name: 'Paramaribo', lat: 5.8520, lng: -55.2038, pop: 240000 },
        { name: 'Georgetown', lat: 6.8013, lng: -58.1553, pop: 118000 },
        // Africa
        { name: 'Cairo', lat: 30.0444, lng: 31.2357, pop: 9900000 },
        { name: 'Algiers', lat: 36.7538, lng: 3.0588, pop: 3416000 },
        { name: 'Tunis', lat: 36.8065, lng: 10.1815, pop: 1050000 },
        { name: 'Rabat', lat: 34.0209, lng: -6.8416, pop: 580000 },
        { name: 'Tripoli', lat: 32.8872, lng: 13.1913, pop: 1150000 },
        { name: 'Khartoum', lat: 15.5007, lng: 32.5599, pop: 5260000 },
        { name: 'Addis Ababa', lat: 8.9806, lng: 38.7578, pop: 3041000 },
        { name: 'Nairobi', lat: -1.2921, lng: 36.8219, pop: 4397000 },
        { name: 'Kampala', lat: 0.3476, lng: 32.5825, pop: 1650000 },
        { name: 'Kigali', lat: -1.9579, lng: 30.1127, pop: 745000 },
        { name: 'Dodoma', lat: -6.1630, lng: 35.7516, pop: 410000 },
        { name: 'Kinshasa', lat: -4.4419, lng: 15.2663, pop: 11900000 },
        { name: 'Brazzaville', lat: -4.2634, lng: 15.2429, pop: 1870000 },
        { name: 'Luanda', lat: -8.8390, lng: 13.2894, pop: 2570000 },
        { name: 'Gaborone', lat: -24.6282, lng: 25.9231, pop: 232000 },
        { name: 'Harare', lat: -17.8292, lng: 31.0522, pop: 1489000 },
        { name: 'Maputo', lat: -25.9692, lng: 32.5732, pop: 1100000 },
        { name: 'Pretoria', lat: -25.7479, lng: 28.2293, pop: 741000 },
        { name: 'Cape Town', lat: -33.9249, lng: 18.4241, pop: 4337000 },
        { name: 'Maseru', lat: -29.3151, lng: 27.4869, pop: 331000 },
        { name: 'Mbabane', lat: -26.3054, lng: 31.1367, pop: 95000 },
        { name: 'Antananarivo', lat: -18.8792, lng: 47.5079, pop: 1390000 },
        { name: 'Port Louis', lat: -20.1609, lng: 57.5012, pop: 148000 },
        { name: 'Victoria', lat: -4.6191, lng: 55.4513, pop: 26000 },
        { name: 'Lusaka', lat: -15.3875, lng: 28.3228, pop: 1743000 },
        { name: 'Lilongwe', lat: -13.9626, lng: 33.7741, pop: 989000 },
        { name: 'Bujumbura', lat: -3.3614, lng: 29.3599, pop: 331000 },
        { name: 'Abuja', lat: 9.0765, lng: 7.3986, pop: 1236000 },
        { name: 'Accra', lat: 5.6037, lng: -0.1870, pop: 2300000 },
        { name: 'Lomé', lat: 6.1725, lng: 1.2314, pop: 837000 },
        { name: 'Cotonou', lat: 6.3703, lng: 2.3912, pop: 680000 },
        { name: 'Porto-Novo', lat: 6.4969, lng: 2.6289, pop: 265000 },
        { name: 'Ouagadougou', lat: 12.3714, lng: -1.5197, pop: 2450000 },
        { name: 'Niamey', lat: 13.5116, lng: 2.1254, pop: 1200000 },
        { name: 'Bamako', lat: 12.6392, lng: -7.9999, pop: 2250000 },
        { name: 'Dakar', lat: 14.7167, lng: -17.4677, pop: 1146000 },
        { name: 'Banjul', lat: 13.4549, lng: -16.5790, pop: 31000 },
        { name: 'Praia', lat: 14.9330, lng: -23.5133, pop: 159000 },
        { name: 'Nouakchott', lat: 18.0735, lng: -15.9582, pop: 960000 },
        { name: 'Al-Uyun', lat: 27.1536, lng: -13.2033, pop: 220000 },
        { name: 'Freetown', lat: 8.4657, lng: -13.2317, pop: 1050000 },
        { name: 'Conakry', lat: 9.6412, lng: -13.5784, pop: 1660000 },
        { name: 'Monrovia', lat: 6.3156, lng: -10.8074, pop: 1060000 },
        { name: 'Abidjan', lat: 5.3476, lng: -4.0276, pop: 4765000 },
        { name: 'Yamoussoukro', lat: 6.8276, lng: -5.2893, pop: 212000 },
        { name: 'Yaoundé', lat: 3.8480, lng: 11.5021, pop: 2440000 },
        { name: 'Libreville', lat: 0.4162, lng: 9.4673, pop: 797000 },
        { name: 'Malabo', lat: 3.7500, lng: 8.7833, pop: 297000 },
        // Asia & Oceania
        { name: 'Ankara', lat: 39.9334, lng: 32.8597, pop: 5500000 },
        { name: 'Yerevan', lat: 40.1772, lng: 44.5035, pop: 1090000 },
        { name: 'Tbilisi', lat: 41.7151, lng: 44.8271, pop: 1190000 },
        { name: 'Baku', lat: 40.4093, lng: 49.8671, pop: 2220000 },
        { name: 'Tehran', lat: 35.6892, lng: 51.3890, pop: 8847000 },
        { name: 'Baghdad', lat: 33.3128, lng: 44.3615, pop: 7181000 },
        { name: 'Riyadh', lat: 24.7136, lng: 46.6753, pop: 6880000 },
        { name: 'Kuwait City', lat: 29.3759, lng: 47.9774, pop: 3000000 },
        { name: 'Manama', lat: 26.2235, lng: 50.5876, pop: 200000 },
        { name: 'Doha', lat: 25.2854, lng: 51.5310, pop: 956000 },
        { name: 'Abu Dhabi', lat: 24.4539, lng: 54.3773, pop: 1500000 },
        { name: 'Muscat', lat: 23.5859, lng: 58.4059, pop: 1420000 },
        { name: 'Sanaa', lat: 15.3694, lng: 44.1910, pop: 2950000 },
        { name: 'Amman', lat: 31.9539, lng: 35.9106, pop: 4000000 },
        { name: 'Damascus', lat: 33.5138, lng: 36.2765, pop: 1711000 },
        { name: 'Beirut', lat: 33.8938, lng: 35.5018, pop: 2400000 },
        { name: 'Jerusalem', lat: 31.7683, lng: 35.2137, pop: 936000 },
        { name: 'Cairo', lat: 30.0444, lng: 31.2357, pop: 9900000 },
        { name: 'Nur-Sultan', lat: 51.1694, lng: 71.4491, pop: 1000000 },
        { name: 'Tashkent', lat: 41.2995, lng: 69.2401, pop: 2550000 },
        { name: 'Bishkek', lat: 42.8746, lng: 74.5698, pop: 1000000 },
        { name: 'Dushanbe', lat: 38.5598, lng: 68.7870, pop: 863000 },
        { name: 'Ashgabat', lat: 37.9601, lng: 58.3261, pop: 1037000 },
        { name: 'Ulaanbaatar', lat: 47.8864, lng: 106.9057, pop: 1480000 },
        { name: 'New Delhi', lat: 28.6139, lng: 77.2090, pop: 16787941 },
        { name: 'Islamabad', lat: 33.6844, lng: 73.0479, pop: 1016000 },
        { name: 'Kathmandu', lat: 27.7172, lng: 85.3240, pop: 1440000 },
        { name: 'Thimphu', lat: 27.4728, lng: 89.6390, pop: 115000 },
        { name: 'Dhaka', lat: 23.8103, lng: 90.4125, pop: 8906000 },
        { name: 'Colombo', lat: 6.9271, lng: 79.8612, pop: 561000 },
        { name: 'Malé', lat: 4.1755, lng: 73.5093, pop: 252000 },
        { name: 'Naypyidaw', lat: 19.7633, lng: 96.0785, pop: 1160000 },
        { name: 'Bangkok', lat: 13.7563, lng: 100.5018, pop: 8281000 },
        { name: 'Vientiane', lat: 17.9757, lng: 102.6331, pop: 948000 },
        { name: 'Hanoi', lat: 21.0278, lng: 105.8342, pop: 8000000 },
        { name: 'Phnom Penh', lat: 11.5564, lng: 104.9282, pop: 2129000 },
        { name: 'Kuala Lumpur', lat: 3.1390, lng: 101.6869, pop: 1800000 },
        { name: 'Singapore', lat: 1.3521, lng: 103.8198, pop: 5639000 },
        { name: 'Bandar Seri Begawan', lat: 4.9031, lng: 114.9398, pop: 100000 },
        { name: 'Jakarta', lat: -6.2088, lng: 106.8456, pop: 10187000 },
        { name: 'Manila', lat: 14.5995, lng: 120.9842, pop: 1780000 },
        { name: 'Tokyo', lat: 35.6762, lng: 139.6503, pop: 13929286 },
        { name: 'Seoul', lat: 37.5665, lng: 126.9780, pop: 9776000 },
        { name: 'Pyongyang', lat: 39.0392, lng: 125.7625, pop: 3100000 },
        { name: 'Beijing', lat: 39.9042, lng: 116.4074, pop: 21540000 },
        { name: 'Taipei', lat: 25.0330, lng: 121.5654, pop: 2602000 },
        { name: 'Ulaanbaatar', lat: 47.8864, lng: 106.9057, pop: 1480000 },
        { name: 'Canberra', lat: -35.2809, lng: 149.1300, pop: 462000 },
        { name: 'Wellington', lat: -41.2866, lng: 174.7756, pop: 215000 },
        { name: 'Suva', lat: -18.1248, lng: 178.4501, pop: 88271 },
        { name: 'Port Moresby', lat: -9.4438, lng: 147.1803, pop: 383000 },
        { name: 'Honiara', lat: -9.4456, lng: 159.9729, pop: 68000 },
        { name: 'Apia', lat: -13.8333, lng: -171.8333, pop: 37500 },
        { name: 'Nukuʻalofa', lat: -21.1394, lng: -175.2042, pop: 24000 }
    ];
    let labelsAttached = false;
    let envIsOcean = false;

    // --- Performance mode ---
    // Force high-quality rendering and assets.
    const PERF = 'high';
    const MAX_CAPITAL_LABELS = 100;
    const STEPS_POLY = 128;
    const STEPS_RIM = 256;
    const STEPS_HOVER = 192;

    // Create Globe with a conservative WebGL config to avoid context failures
    const globeContainer = document.getElementById('globeViz');
    function createGlobeInstance() {
        const primaryConfig = {
            rendererConfig: {
                antialias: false,
                alpha: false,
                depth: true,
                stencil: false,
                preserveDrawingBuffer: false,
                powerPreference: 'high-performance',
                failIfMajorPerformanceCaveat: false,
                precision: 'mediump',
                logarithmicDepthBuffer: false
            }
        };
        try {
            return Globe(primaryConfig)(globeContainer);
        } catch (e) {
            // Retry with even more permissive/lower-power config
            try {
                const fallbackConfig = {
                    rendererConfig: {
                        antialias: false,
                        alpha: false,
                        depth: true,
                        stencil: false,
                        preserveDrawingBuffer: false,
                        powerPreference: 'low-power',
                        failIfMajorPerformanceCaveat: false,
                        precision: 'mediump',
                        logarithmicDepthBuffer: false
                    }
                };
                return Globe(fallbackConfig)(globeContainer);
            } catch (e2) {
                // Surface a friendly message in the UI
                try {
                    const msg = document.createElement('div');
                    msg.style.cssText = 'position:absolute;inset:0;display:flex;align-items:center;justify-content:center;color:#e66;background:#000;';
                    msg.textContent = 'WebGL failed to initialize. Please enable WebGL or try a different browser/device.';
                    globeContainer.appendChild(msg);
                } catch(_) {}
                throw e2;
            }
        }
    }
    const globe = createGlobeInstance()
        .pointsData([])
        .showAtmosphere(true)
        .atmosphereAltitude(0.275)
        .ringsData(rings)
        .ringColor(r => () => (r.color || 'rgba(255,0,0,0.85)'))
        .ringMaxRadius('maxR')
        .ringPropagationSpeed('propagationSpeed')
        .ringRepeatPeriod('repeatPeriod')
        .polygonsData(burnPolys)
        .polygonCapColor(f => (f.properties && f.properties.fill) || 'rgba(255,255,0,0.20)')
        .polygonSideColor(f => (f.properties && f.properties.fill) || 'rgba(255,255,0,0.20)')
        .polygonStrokeColor(f => (f.properties && f.properties.stroke) || '#ffff00')
        .polygonAltitude(f => (f.properties && typeof f.properties.alt === 'number') ? f.properties.alt : 0.01)
        .polygonLabel(f => (f.properties && f.properties.label) || '')
        .polygonsTransitionDuration(0);

    // Always use high-resolution textures
    try {
        globe.globeImageUrl('./resources/8081_earthmap10k.jpg');
        globe.bumpImageUrl('./resources/8081_earthbump10k.jpg');
    } catch(_) {}

    const globeMaterial = globe.globeMaterial();
    globeMaterial.bumpScale = 30;
    // Remove specular for stability; keep bump map
    globeMaterial.specularMap = null;
    globeMaterial.shininess = 0;

    const scene = globe.scene();
    const camera = globe.camera();
    const renderer = globe.renderer();
    // Cap pixel ratio to reduce canvas memory usage (force 1.0 for stability)
    try { renderer.setPixelRatio(1.0); } catch(e) {}

    function cartesianToLatLng(pos, radius = ETALON) {
        const x = pos.x / radius;
        const y = pos.y / radius;
        const z = pos.z / radius;
        const lat = Math.asin(y) * 180 / Math.PI;
        const lng = Math.atan2(x, z) * 180 / Math.PI;
        return { lat, lng };
    }
    function latLngToVec3(latDeg, lonDeg, radius = ETALON) {
        const lat = THREE.MathUtils.degToRad(latDeg);
        const lon = THREE.MathUtils.degToRad(lonDeg);
        const x = radius * Math.cos(lat) * Math.sin(lon);
        const y = radius * Math.sin(lat);
        const z = radius * Math.cos(lat) * Math.cos(lon);
        return new THREE.Vector3(x, y, z);
    }
    // Geodesic destination point on a sphere
    function destinationPoint(lonDeg, latDeg, bearingRad, distanceKm) {
        const R = 6371.0088; // km
        const δ = distanceKm / R;
        const φ1 = THREE.MathUtils.degToRad(latDeg);
        const λ1 = THREE.MathUtils.degToRad(lonDeg);
        const θ = bearingRad;
        const sinφ2 = Math.sin(φ1)*Math.cos(δ) + Math.cos(φ1)*Math.sin(δ)*Math.cos(θ);
        const φ2 = Math.asin(sinφ2);
        const y = Math.sin(θ)*Math.sin(δ)*Math.cos(φ1);
        const x = Math.cos(δ) - Math.sin(φ1)*Math.sin(φ2);
        const λ2 = λ1 + Math.atan2(y, x);
        const lon2 = THREE.MathUtils.radToDeg((λ2 + Math.PI) % (2*Math.PI) - Math.PI);
        const lat2 = THREE.MathUtils.radToDeg(φ2);
        return [lon2, lat2];
    }
    function circleFeature(lon, lat, radiusKm, steps = STEPS_POLY, props = {}) {
        if (!Number.isFinite(radiusKm) || radiusKm <= 0) return null;
        const coords = [];
        for (let i = 0; i <= steps; i++) {
            const b = 2 * Math.PI * (i / steps);
            const [x, y] = destinationPoint(lon, lat, b, radiusKm);
            coords.push([x, y]);
        }
        return { type: 'Feature', properties: props, geometry: { type: 'Polygon', coordinates: [coords] } };
    }
    // Simple transliteration to avoid '?' for unsupported glyphs on canvas labels
    function transliterate(s) {
        try {
            if (!s) return '';
            let t = String(s);
            try { t = t.normalize('NFD').replace(/[\u0300-\u036f]/g, ''); } catch(_) {}
            const map = {
                'ß':'ss','Ø':'O','ø':'o','Ł':'L','ł':'l','Đ':'D','đ':'d','Œ':'OE','œ':'oe','Æ':'AE','æ':'ae',
                'Þ':'Th','þ':'th','Å':'A','å':'a','Ğ':'G','ğ':'g','Ş':'S','ş':'s','Č':'C','č':'c','Ć':'C','ć':'c',
                'Ž':'Z','ž':'z','Ñ':'N','ñ':'n','İ':'I','ı':'i'
            };
            t = t.replace(/[ßØøŁłĐđŒœÆæÞþÅåĞğŞşČčĆćŽžÑñİı]/g, c => map[c] || '');
            t = t.replace(/[^\x20-\x7E]/g, '');
            return t;
        } catch(_) { return String(s || ''); }
    }
    function annulusFeature(lon, lat, radiusOuterKm, thicknessKm, steps = 128, props = {}) {
        if (!Number.isFinite(radiusOuterKm) || radiusOuterKm <= 0) return null;
        const rIn = Math.max(0.0001, radiusOuterKm - Math.max(0.001, thicknessKm));
        const rOut = radiusOuterKm;
        const outer = [];
        const inner = [];
        for (let i = 0; i <= steps; i++) {
            const t = i / steps;
            const b = 2 * Math.PI * t;
            const [xo, yo] = destinationPoint(lon, lat, b, rOut);
            const [xi, yi] = destinationPoint(lon, lat, b, rIn);
            outer.push([xo, yo]);
            inner.push([xi, yi]);
        }
        inner.reverse(); // opposite winding for hole
        return { type: 'Feature', properties: props, geometry: { type: 'Polygon', coordinates: [outer, inner] } };
    }

    // Hover circle overlay as a thin line loop (drawn on top, no depth test)
    function showHoverCircle(lon, lat, radiusKm, steps = STEPS_HOVER) {
        clearHoverCircle();
        if (!Number.isFinite(radiusKm) || radiusKm <= 0) return;
        const pts = [];
        for (let i = 0; i < steps; i++) {
            const b = 2 * Math.PI * (i / steps);
            const [x, y] = destinationPoint(lon, lat, b, radiusKm);
            const v = latLngToVec3(y, x, ETALON + 1); // slightly above surface
            pts.push(v);
        }
        const geom = new THREE.BufferGeometry().setFromPoints(pts);
        const mat = new THREE.LineBasicMaterial({ color: 0x00ffff, transparent: true, opacity: 0.9, depthTest: false });
        const loop = new THREE.LineLoop(geom, mat);
        loop.renderOrder = 9999;
        // Do not block globe.gl raycasting (tooltips)
        try { loop.raycast = () => {}; } catch(_) {}
        scene.add(loop);
        hoverCircle = loop;
    }
    function clearHoverCircle() {
        if (!hoverCircle) return;
        try {
            scene.remove(hoverCircle);
            if (hoverCircle.geometry) { try { hoverCircle.geometry.dispose(); } catch(e) {} }
            if (hoverCircle.material) { try { hoverCircle.material.dispose(); } catch(e) {} }
        } catch(e) {}
        hoverCircle = null;
    }

    function setCraterRimCircle(lon, lat, radiusKm, color = 0xffffff, steps = STEPS_RIM) {
        clearCraterRimCircle();
        if (!Number.isFinite(radiusKm) || radiusKm <= 0) return;
        const pts = [];
        for (let i = 0; i < steps; i++) {
            const b = 2 * Math.PI * (i / steps);
            const [x, y] = destinationPoint(lon, lat, b, radiusKm);
            const v = latLngToVec3(y, x, ETALON + 1.5);
            pts.push(v);
        }
        const geom = new THREE.BufferGeometry().setFromPoints(pts);
        const mat = new THREE.LineBasicMaterial({ color, transparent: true, opacity: 1.0, depthTest: false });
        const loop = new THREE.LineLoop(geom, mat);
        loop.renderOrder = 9998;
        // Do not intercept raycasting for tooltips
        try { loop.raycast = () => {}; } catch(_) {}
        scene.add(loop);
        craterRim = loop;
    }
    function clearCraterRimCircle() {
        if (!craterRim) return;
        try {
            scene.remove(craterRim);
            if (craterRim.geometry) { try { craterRim.geometry.dispose(); } catch(e) {} }
            if (craterRim.material) { try { craterRim.material.dispose(); } catch(e) {} }
        } catch(e) {}
        craterRim = null;
    }

    function updateRings() {
        const now = Date.now();
        let removed = 0;
        for (let i = rings.length - 1; i >= 0; i--) {
            if (now - rings[i].createdAt >= rings[i].lifetime) {
                rings.splice(i, 1);
                removed++;
            }
        }
        if (removed > 0 || ringsDirty) {
            ringsDirty = false;
            globe.ringsData(rings);
        }
    }
    function updatePolygons() {
        if (burnPolysDirty) {
            burnPolysDirty = false;
            try { globe.polygonsData(burnPolys); } catch(e) {}
        }
    }

    class Asteroid {
        constructor(radius = 10, position = new THREE.Vector3(0,0,0), target = new THREE.Vector3(0,0,0), speed = 5, modelTemplate = null, opts = {}) {
            const { scale = 1, initialEuler = null, spinAxis = null, spinSpeed = 0 } = opts;

            if (modelTemplate) {
                this.mesh = modelTemplate.clone(true);
                this.mesh.traverse(o => {
                    if (o.isMesh) {
                        o.castShadow = true;
                        o.receiveShadow = true;
                    }
                });
                this.mesh.scale.multiplyScalar(scale);
                if (initialEuler) this.mesh.rotation.copy(initialEuler);
                else this.mesh.rotation.set(Math.random()*2*Math.PI, Math.random()*2*Math.PI, Math.random()*2*Math.PI);
            } else {
                this.mesh = new THREE.Mesh(
                    new THREE.SphereGeometry(radius, 32, 32),
                    new THREE.MeshStandardMaterial({ color: 0x888888 })
                );
            }

            this.mesh.position.copy(position);
            this.direction = target.clone().sub(position).normalize();
            this.speed = speed;
            this.radius = radius;
            this.isKaboom = false;
            this.spinAxis = (spinAxis ?? new THREE.Vector3(Math.random()-0.5, Math.random()-0.5, Math.random()-0.5)).normalize();
            this.spinSpeed = spinSpeed;

            const trajectoryEnd = position.clone().add(this.direction.clone().multiplyScalar(10000));
            const geometry = new THREE.BufferGeometry().setFromPoints([position.clone(), trajectoryEnd]);
            const material = new THREE.LineDashedMaterial({
                color: 0x888888,
                dashSize: 20,
                gapSize: 20,
                linewidth: 1.2,
                transparent: true,
                opacity: 0.4
            });
            this.trajectory = new THREE.Line(geometry, material);
            this.trajectory.computeLineDistances();

            scene.add(this.mesh);
            scene.add(this.trajectory);
        }

        dispose() {
            try {
                if (this.mesh) {
                    this.mesh.traverse(o => {
                        if (o.isMesh) {
                            if (o.geometry) { try { o.geometry.dispose(); } catch(e) {} }
                            if (o.material) {
                                const m = o.material;
                                if (Array.isArray(m)) m.forEach(mm => { try { mm.dispose(); } catch(e) {} });
                                else { try { m.dispose(); } catch(e) {} }
                            }
                        }
                    });
                    scene.remove(this.mesh);
                }
            } catch(e) {}
            try {
                if (this.trajectory) {
                    if (this.trajectory.geometry) { try { this.trajectory.geometry.dispose(); } catch(e) {} }
                    if (this.trajectory.material) { try { this.trajectory.material.dispose(); } catch(e) {} }
                    scene.remove(this.trajectory);
                }
            } catch(e) {}
            this.mesh = null;
            this.trajectory = null;
        }

        checkCollision(prevPos) {
            if (this.isKaboom) return false;
            const ray = new THREE.Ray(prevPos, this.mesh.position.clone().sub(prevPos).normalize());
            const distance = prevPos.distanceTo(this.mesh.position);
            const hit = ray.intersectSphere(new THREE.Sphere(EARTH_CENTER, ETALON + this.radius), new THREE.Vector3());
            if (hit && prevPos.distanceTo(hit) <= distance) {
                this.isKaboom = true;
                // Use known impact coordinates if available; otherwise fall back
                let lat, lng;
                if (impactLatLng) {
                    lat = Number(impactLatLng.lat);
                    lng = Number(impactLatLng.lng);
                } else if (impactTargetVec) {
                    ({ lat, lng } = cartesianToLatLng(impactTargetVec));
                } else {
                    ({ lat, lng } = cartesianToLatLng(hit));
                }
                const now = Date.now();
                if (plannedRingKm.length) {
                    for (const rkm of plannedRingKm) {
                        const deg = rkm / 111; // km -> deg approx
                        rings.push({ lat, lng, maxR: deg, propagationSpeed: 10, repeatPeriod: 0.1, color: 'red', createdAt: now, lifetime: 4000 });
                    }
                } else {
                    rings.push({ lat, lng, maxR: 0.8, propagationSpeed: 10, repeatPeriod: 0.1, color: 'red', createdAt: now, lifetime: 3000 });
                }
                ringsDirty = true;
                this.dispose();
                // remove from active list
                const idx = asteroids.indexOf(this);
                if (idx >= 0) asteroids.splice(idx, 1);
                return true;
            }
            return false;
        }

        animate(dt = 1/60) {
            if (this.spinSpeed !== 0) this.mesh.rotateOnAxis(this.spinAxis, this.spinSpeed * dt);
            const prevPos = this.mesh.position.clone();
            this.mesh.position.add(this.direction.clone().multiplyScalar(this.speed * dt));
            this.checkCollision(prevPos);
        }
    }

    globe.onGlobeReady(() => {
        const loader = new GLTFLoader();
        camera.position.set(500, 260, 520);

        // Lights
        const sunLight = new THREE.DirectionalLight(0xffffff, 2);
        sunLight.position.set(1000,1000,1000);
        scene.add(sunLight);

        // Sky: procedural starfield only (no external textures)
        let starfield = null;
        function buildStarfield(count = (PERF === 'low' ? 1000 : 4000), radius = 5000) {
            try {
                const geom = new THREE.BufferGeometry();
                const positions = new Float32Array(count * 3);
                const colors = new Float32Array(count * 3);
                const color = new THREE.Color();
                for (let i = 0; i < count; i++) {
                    // Random point on a sphere
                    const u = Math.random();
                    const v = Math.random();
                    const theta = 2 * Math.PI * u;
                    const phi = Math.acos(2 * v - 1);
                    const r = radius;
                    const x = r * Math.sin(phi) * Math.cos(theta);
                    const y = r * Math.cos(phi);
                    const z = r * Math.sin(phi) * Math.sin(theta);
                    positions[3*i+0] = x;
                    positions[3*i+1] = y;
                    positions[3*i+2] = z;
                    // Slight color variance around white/blue
                    color.setHSL(0.60 + Math.random()*0.05, 0.2, 0.8 + Math.random()*0.2);
                    colors[3*i+0] = color.r;
                    colors[3*i+1] = color.g;
                    colors[3*i+2] = color.b;
                }
                geom.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                geom.setAttribute('color', new THREE.BufferAttribute(colors, 3));
                const mat = new THREE.PointsMaterial({ size: 2.0, sizeAttenuation: false, vertexColors: true, depthWrite: false, transparent: true, opacity: 0.9 });
                const points = new THREE.Points(geom, mat);
                points.frustumCulled = false;
                // Avoid intercepting pointer raycasts (tooltips should hit the globe polygons)
                try { points.raycast = () => {}; } catch(_) {}
                scene.add(points);
                return points;
            } catch(e) { return null; }
        }
        function setupSky() {
            try { scene.background = new THREE.Color(0x000008); } catch(_) {}
            starfield = buildStarfield();
        }
        setupSky();
        const hemisphere = new THREE.HemisphereLight(0xffffff, 0x444444, 1.5);
        scene.add(hemisphere);

        renderer.shadowMap.enabled = true;

        // Omit debug helpers to reduce geometry overhead

        // Read context from index page (impact lat/lon and optional rings)
        try {
            const raw = localStorage.getItem('terv_ctx');
            if (raw) {
                const ctx = JSON.parse(raw);
                if (ctx?.impact?.lat != null && ctx?.impact?.lon != null) {
                    const lat = Number(ctx.impact.lat);
                    const lng = Number(ctx.impact.lon);
                    impactLatLng = { lat, lng };
                    // Smaller, subtle marker; comment out to hide completely
                    globe.pointsData([{ lat, lng, size: 0.5, color: 'rgba(255,80,80,0.95)' }]);

                    // Save ring radii (km) to render upon actual impact
                    plannedRingKm = String(ctx.rings || '')
                        .split(',')
                        .map(s => Number(s.trim()))
                        .filter(x => x>0);
                }
            }
        } catch (e) { /* ignore */ }

        function spawnAsteroidTo(targetVec) {
            const dirFromFar = targetVec.clone().normalize();
            const startPos = targetVec.clone().add(dirFromFar.clone().multiplyScalar(1500));
            const radius = 10;
            const speed = 110;
            const scale = 1.5;
            const spinAxis = new THREE.Vector3(0.3, 0.7, 0.2).normalize();
            const spinSpeed = 0.4;
            const asteroid = new Asteroid(radius, startPos, targetVec, speed, asteroidTemplate, { scale, spinAxis, spinSpeed });
            asteroids.push(asteroid);
            followTarget = asteroid;
            const behind = asteroid.direction.clone().multiplyScalar(-25);
            const up = new THREE.Vector3(0,1,0);
            const side = new THREE.Vector3().crossVectors(asteroid.direction, up).normalize().multiplyScalar(10);
            const camPos = asteroid.mesh.position.clone().add(behind).add(side).add(up.clone().multiplyScalar(4));
            camera.position.copy(camPos);
            camera.lookAt(asteroid.mesh.position);
            camera.fov = 85;
            camera.updateProjectionMatrix();
            try {
                const controls = globe.controls && globe.controls();
                if (controls) {
                    controls.target.copy(asteroid.mesh.position);
                    controls.update?.();
                }
            } catch(e) {}

            // Start prefetching backend data for the intended impact location
            try {
                const ll = cartesianToLatLng(targetVec, ETALON);
                startPrefetch(ll.lat, ll.lng);
            } catch(e) {}
        }

        function targetVecFromContextOrCenter() {
            let target = EARTH_CENTER.clone();
            try {
                const raw = localStorage.getItem('terv_ctx');
                if (raw) {
                    const ctx = JSON.parse(raw);
                    if (ctx?.impact?.lat != null && ctx?.impact?.lon != null) {
                        const lat = THREE.MathUtils.degToRad(ctx.impact.lat);
                        const lon = THREE.MathUtils.degToRad(ctx.impact.lon);
                        const x = ETALON * Math.cos(lat) * Math.sin(lon);
                        const y = ETALON * Math.sin(lat);
                        const z = ETALON * Math.cos(lat) * Math.cos(lon);
                        target = new THREE.Vector3(x, y, z);
                        impactTargetVec = target.clone();
                    }
                }
            } catch(e) {}
            return target;
        }

        loader.load('./models/asteroid.glb', gltf => {
            asteroidTemplate = gltf.scene;
            asteroidTemplate.traverse(o => {
                if (o.isMesh) {
                    o.castShadow = true;
                    o.receiveShadow = true;
                    o.material = new THREE.MeshStandardMaterial({
                        color: 0x888888,
                        roughness: 0.5,
                        metalness: 0.6,
                        emissive: 0x222222,
                        emissiveIntensity: 0.8
                    });
                }
            });
            asteroidTemplate.scale.setScalar(1);

            spawnAsteroidTo(targetVecFromContextOrCenter());
            try { setupOverlay(); } catch(e) {}
            try { initSound(); if (sound.enabled && sound.impactAudio) sound.impactAudio.volume = 0.9; } catch(e) { console.warn(e); }
        });
    });

    // Main animation loop
    (function animate() {
        rafId = requestAnimationFrame(animate);
        const dt = clock.getDelta();
        asteroids.forEach(a => a.animate(dt));
        // Smooth follow camera on the tracked asteroid
        if (followTarget) {
            if (followTarget.isKaboom) {
                followTarget = null; // stop following after impact
            } else {
                const dir = followTarget.direction.clone();
                const behind = dir.clone().multiplyScalar(-18);
                const up = new THREE.Vector3(0,1,0);
                const side = new THREE.Vector3().crossVectors(dir, up).normalize().multiplyScalar(8);
                const desired = followTarget.mesh.position.clone().add(behind).add(side).add(up.clone().multiplyScalar(3));
                // Apply camera shake offset
                const t = performance.now() * 0.001;
                const shakeAmp = currentShakeAmount();
                const sh = new THREE.Vector3(
                    (Math.sin(t * shake.freq.x) + Math.cos(t * 2.1)) * 0.5,
                    (Math.sin(t * shake.freq.y) + Math.cos(t * 1.7)) * 0.5,
                    (Math.sin(t * shake.freq.z) + Math.cos(t * 2.7)) * 0.5
                ).multiplyScalar(shakeAmp * 1.3);
                desired.add(sh);
                camera.position.lerp(desired, 0.22);
                camera.lookAt(followTarget.mesh.position);
                try {
                    const controls = globe.controls && globe.controls();
                    if (controls) {
                        controls.target.lerp(followTarget.mesh.position, 0.35);
                        controls.update?.();
                    }
                } catch(e) {}
            }
        }
        // Zoom onto impact site if requested
        if (zoomTransition.active) {
            const now = performance.now();
            const t = Math.min(1, (now - zoomTransition.start) / zoomTransition.dur);
            const eased = 1 - Math.pow(1 - t, 3); // easeOutCubic
            const cur = new THREE.Vector3().copy(zoomTransition.fromPos).lerp(zoomTransition.toPos, eased);
            camera.position.copy(cur);
            camera.fov = THREE.MathUtils.lerp(zoomTransition.fromFov, zoomTransition.toFov, eased);
            camera.updateProjectionMatrix();
            if (zoomTransition.aim) {
                camera.lookAt(zoomTransition.aim);
                try {
                    const controls = globe.controls && globe.controls();
                    if (controls) {
                        controls.target.copy(zoomTransition.aim);
                        controls.update?.();
                    }
                } catch(e) {}
            }
            if (t >= 1) zoomTransition.active = false;
        }
        updateRings();
        updatePolygons();
    })();

    // Dispose helpers on unload to release GPU memory
    function disposeNode(node) {
        try {
            if (node.geometry) { try { node.geometry.dispose(); } catch(e) {} }
            if (node.material) {
                const m = node.material;
                if (Array.isArray(m)) m.forEach(mm => { try { mm.dispose(); } catch(e) {} });
                else { try { m.dispose(); } catch(e) {} }
            }
        } catch(e) {}
    }
    function disposeScene() {
        try { if (rafId) { cancelAnimationFrame(rafId); rafId = null; } } catch(e) {}
        try { clearHoverCircle(); } catch(e) {}
        try { clearCraterRimCircle(); } catch(e) {}
        // Dispose active asteroids and template
        try { for (const a of asteroids) { try { a.dispose(); } catch(e) {} } } catch(e) {}
        asteroids = [];
        followTarget = null;
        try { if (asteroidTemplate) { asteroidTemplate.traverse(disposeNode); } } catch(e) {}
        // Clear globe overlays
        try { globe.ringsData([]); } catch(e) {}
        try { globe.polygonsData([]); } catch(e) {}
        try { globe.labelsData && globe.labelsData([]); } catch(e) {}
        try { globe.pointsData && globe.pointsData([]); } catch(e) {}
        // Attempt to call internal destructor if provided by Globe.gl
        try { if (typeof globe._destructor === 'function') globe._destructor(); } catch(e) {}
        // Dispose controls explicitly if present
        try { const c = globe.controls && globe.controls(); if (c && c.dispose) c.dispose(); } catch(e) {}
        // Dispose textures from material on teardown (reset everything)
        try {
            if (globeMaterial) {
                if (globeMaterial.map) { try { globeMaterial.map.dispose(); } catch(_) {} globeMaterial.map = null; }
                if (globeMaterial.bumpMap) { try { globeMaterial.bumpMap.dispose(); } catch(_) {} globeMaterial.bumpMap = null; }
                if (globeMaterial.specularMap) { try { globeMaterial.specularMap.dispose(); } catch(_) {} globeMaterial.specularMap = null; }
            }
        } catch(e) {}
        // Audio cleanup
        try {
            if (sound.impactAudio) {
                sound.impactAudio.pause();
                sound.impactAudio.src = '';
                try { sound.impactAudio.load(); } catch(_) {}
                sound.impactAudio = null;
            }
        } catch(e) {}
        // Dispose background skybox texture / starfield
        try {
            const bg = scene && scene.background;
            if (bg && bg.isTexture && bg.dispose) { bg.dispose(); }
            if (scene) scene.background = null;
        } catch(e) {}
        try {
            if (starfield) {
                const g = starfield.geometry, m = starfield.material;
                try { if (g) g.dispose(); } catch(_) {}
                try { if (m) m.dispose(); } catch(_) {}
                try { scene.remove(starfield); } catch(_) {}
                starfield = null;
            }
        } catch(e) {}
        // Deep-dispose any remaining THREE objects created by Globe.gl
        try {
            const kill = [];
            scene.traverse(o => { if (o && o !== camera) kill.push(o); });
            for (const o of kill) {
                try {
                    if (o.geometry) { try { o.geometry.dispose(); } catch(_) {} }
                    if (o.material) {
                        const m = o.material;
                        if (Array.isArray(m)) { for (const mm of m) { try { mm.dispose(); } catch(_) {} } }
                        else { try { m.dispose(); } catch(_) {} }
                    }
                    if (o.parent) { try { o.parent.remove(o); } catch(_) {} }
                } catch(_) {}
            }
        } catch(_) {}

        // Renderer + GL context loss
        try {
            if (renderer) {
                try { renderer.setAnimationLoop && renderer.setAnimationLoop(null); } catch(_) {}
                renderer.dispose();
                if (renderer.forceContextLoss) { try { renderer.forceContextLoss(); } catch(_) {} }
                const gl = renderer.getContext && renderer.getContext();
                if (gl && gl.getExtension) {
                    const ext = gl.getExtension('WEBGL_lose_context');
                    if (ext && ext.loseContext) { try { ext.loseContext(); } catch(_) {} }
                }
            }
        } catch(e) {}
        // Remove canvas to drop any retained references
        try {
            const el = document.getElementById('globeViz');
            if (el) { while (el.firstChild) el.removeChild(el.firstChild); }
        } catch(e) {}
        // Reset large state objects to aid GC
        try { rings = []; ringsDirty = false; } catch(_) {}
        try { burnPolys = []; burnPolysDirty = false; } catch(_) {}
        try { craterRim = null; hoverCircle = null; } catch(_) {}
        try { followTarget = null; currentImpact = null; impactTargetVec = null; } catch(_) {}
        try { prefetchState = { lat: null, lon: null, isOceanP: null, summaryP: null, popPromises: new Map() }; } catch(_) {}
    }
    window.addEventListener('pagehide', disposeScene);
    window.addEventListener('unload', disposeScene);

    function simulateAnotherImpact() {
        // Clean up any running asteroid
        try { clearHoverCircle(); } catch(e) {}
        try {
            for (const a of asteroids) { try { a.dispose(); } catch(e) {} }
        } catch(e) {}
        asteroids = [];
        followTarget = null;
        // Clear rings and polygons
        rings = [];
        ringsDirty = false;
        try { globe.ringsData([]); } catch(e) {}
        burnPolys = [];
        burnPolysDirty = false;
        try { globe.polygonsData([]); } catch(e) {}
        // Reset impact state and spawn again towards last known impact or context
        impactDone = false;
        let target = impactTargetVec;
        if (!target) {
            if (currentImpact) {
                const lat = THREE.MathUtils.degToRad(currentImpact.lat);
                const lon = THREE.MathUtils.degToRad(currentImpact.lon);
                const x = ETALON * Math.cos(lat) * Math.sin(lon);
                const y = ETALON * Math.sin(lat);
                const z = ETALON * Math.cos(lat) * Math.cos(lon);
                target = new THREE.Vector3(x, y, z);
            } else {
                target = targetVecFromContextOrCenter();
            }
        }
        spawnAsteroidTo(target.clone());
    }

    // Ensure cleanup on navigation to avoid leaking GPU resources (deduped listeners)
    try {
        window.addEventListener('beforeunload', () => { try { disposeScene(); } catch(_) {} });
    } catch(_) {}

    // --- Shake helpers ---
    function triggerShake(amount = 2.5, durationMs = 2000) {
        const now = performance.now();
        shake.active = amount;
        shake.start = now;
        shake.duration = durationMs;
        shake.until = now + durationMs;
    }
    function currentShakeAmount() {
        const now = performance.now();
        if (now >= shake.until || shake.duration <= 0) return shake.base;
        const t = (now - shake.start) / shake.duration; // 0..1
        const fade = Math.max(0, 1 - t);
        return shake.base + shake.active * fade;
    }

    // Patch asteroid collision to trigger shake and sound
    const _checkCollision = Asteroid.prototype.checkCollision;
    Asteroid.prototype.checkCollision = function(prevPos) {
        const hit = _checkCollision.call(this, prevPos);
        if (hit) {
            triggerShake(6.0, 3500);
            if (sound.enabled && sound.impactAudio) {
                try { sound.impactAudio.currentTime = 0; sound.impactAudio.play(); } catch(e) {}
            }
            try {
                // Show stats panel using known impact location
                const loc = (impactLatLng ? impactLatLng
                           : (impactTargetVec ? cartesianToLatLng(impactTargetVec)
                           : cartesianToLatLng(hit)));
                // Remove the location marker point
                try { globe.pointsData([]); } catch(e) {}
                // Save impact location for hover overlays
                try { currentImpact = { lat: Number(loc.lat), lon: Number(loc.lng) }; } catch(e) {}
                onImpact(loc.lat, loc.lng);
            } catch(e) { console.warn('stats init failed', e); }
        }
        return hit;
    };

    // --- Sound helpers & overlay ---
    function setupOverlay() {
        const ui = document.createElement('div');
        ui.style.position = 'fixed';
        ui.style.top = '12px';
        ui.style.left = '12px';
        ui.style.zIndex = '10';
        ui.style.display = 'flex';
        ui.style.gap = '8px';
        ui.style.alignItems = 'center';
        const btn = document.createElement('button');
        btn.textContent = sound.enabled ? 'Disable Sound' : 'Enable Sound';
        btn.style.padding = '6px 10px';
        btn.style.borderRadius = '8px';
        btn.style.border = '1px solid #22304a';
        btn.style.background = '#24324a';
        btn.style.color = '#e6eefc';
        btn.addEventListener('click', () => {
            sound.enabled = !sound.enabled;
            btn.textContent = sound.enabled ? 'Disable Sound' : 'Enable Sound';
            if (sound.enabled && sound.impactAudio) {
                try { sound.impactAudio.play().then(()=>{ sound.impactAudio.pause(); sound.impactAudio.currentTime = 0; }); } catch(e) {}
            }
        });
        ui.appendChild(btn);
        document.body.appendChild(ui);
    }
    function initSound() {
        const q = new URLSearchParams(window.location.search);
        const ls = localStorage.getItem('terv_sound_impact') || '';
        const url = q.get('impactSound') || ls || './resources/impact.mp3';
        sound.impactUrl = url;
        // Prepare HTMLAudio (simple and reliable)
        try {
            const a = new Audio(url);
            a.preload = 'auto';
            a.volume = 0.9;
            a.crossOrigin = 'anonymous';
            sound.impactAudio = a;
        } catch(e) { console.warn('audio init failed', e); }
    }

    // --- Stats panel & API integration ---
    function onImpact(lat, lon) {
        if (impactDone) return; impactDone = true;
        try { currentImpact = { lat: Number(lat), lon: Number(lon) }; } catch(e) {}
        const root = document.getElementById('viewRoot');
        if (root) root.classList.add('split');
        const panel = document.getElementById('statsPanel');
        panel.style.display = 'block';
        panel.innerHTML = '';
        panel.appendChild(buildHeader(lat, lon));
        panel.appendChild(buildKpiGrid());
        panel.appendChild(buildImpactSections());
        try { renderMeteorDetails(); } catch(e) {}
        // Attach city labels lazily once the sidebar appears
        try {
            if (!labelsAttached) {
                // Try local capitals from cities500.json; fallback to small built-in capitals list
                const topCapitals = (cities, limit = MAX_CAPITAL_LABELS) => {
                    try {
                        const arr = Array.isArray(cities) ? cities.slice() : [];
                        arr.sort((a,b) => (Number(b.pop||0) - Number(a.pop||0)));
                        return arr.slice(0, Math.max(1, limit));
                    } catch(_) { return cities; }
                };
                const setupLabels = (cities) => {
                    try {
                        const data = topCapitals(cities);
                        globe
                          .labelsData(data)
                          .labelLat('lat')
                          .labelLng('lng')
                          .labelText(d => transliterate(d.name))
                          .labelSize(d => 0.42 + Math.min(0.12, (d.pop||0) / 3e8))
                          .labelColor(() => 'rgba(235,245,255,0.9)')
                          .labelResolution(2)
                          .labelAltitude(0.015)
                          .labelIncludeDot(true)
                          .labelDotRadius(0.08)
                          .labelDotColor(() => 'rgba(255,255,255,0.9)');
                        labelsAttached = true;
                    } catch(_) {}
                };
                if (PERF !== 'low') {
                  fetch('./resources/cities500.json')
                  .then(res => res.ok ? res.json() : null)
                  .then(data => {
                      try {
                          let cities = [];
                          if (Array.isArray(data)) {
                              // Expect objects with at least: name, lat, lng, fclass/fcode/pop
                              for (const c of data) {
                                  const name = c.name || c.asciiName || '';
                                  const lat = Number(c.lat ?? c.latitude);
                                  const lng = Number(c.lng ?? c.longitude);
                                  const fclass = (c.fclass || c.featureClass || '').toString();
                                  const fcode = (c.fcode || c.featureCode || '').toString();
                                  const pop = Number(c.population || c.pop || 0);
                                  if (fclass !== 'P' || fcode !== 'PPLC') continue; // capitals only
                                  if (!Number.isFinite(lat) || !Number.isFinite(lng)) continue;
                                  cities.push({ name, lat, lng, pop });
                              }
                          }
                          if (cities.length) {
                              setupLabels(cities);
                              return;
                          }
                      } catch(_) {}
                      // Fallback: extended capitals set (built-in)
                      setupLabels(capitalsExtended);
                  })
                  .catch(() => {
                      setupLabels(capitalsExtended);
                  });
                } else {
                  setupLabels(capitalsExtended);
                }
            }
        } catch(e) {}
        // Add action to simulate another impact
        try {
            const act = document.createElement('div');
            act.className = 'footer';
            const btn = document.createElement('button');
            btn.textContent = 'Simulate another impact';
            btn.style.padding = '10px 12px';
            btn.style.borderRadius = '10px';
            btn.style.border = '1px solid #22304a';
            btn.style.background = '#2b3b5a';
            btn.style.color = '#e6eefc';
            btn.style.fontWeight = '600';
            btn.addEventListener('click', () => {
                try { disposeScene(); } catch(_) {}
                window.location.href = 'index.html';
            });
            act.appendChild(btn);
            panel.appendChild(act);
        } catch(e) {}
        // Resize renderer to new layout
        queueResize();
        // Dramatic zoom onto the impact point
        try {
            const aim = latLngToVec3(lat, lon, ETALON);
            const fromPos = camera.position.clone();
            const outward = aim.clone().normalize();
            const toPos = outward.clone().multiplyScalar(ETALON + 24); // ~24 units above surface
            zoomTransition = {
                active: true,
                start: performance.now(),
                dur: 1200,
                fromPos,
                toPos,
                fromFov: camera.fov,
                toFov: 38,
                aim
            };
        } catch(e) {}
        // Use prefetched API calls if available to minimize wait
        (async () => {
            try {
                let isOcean = false;
                if (prefetchState && prefetchState.isOceanP) {
                    try { isOcean = await prefetchState.isOceanP; } catch(_) { isOcean = await fetchIsOcean(lat, lon); }
                } else {
                    isOcean = await fetchIsOcean(lat, lon);
                }
                setText('kEnv', isOcean ? 'Ocean' : 'Land');
                envIsOcean = !!isOcean;

                let summary = null;
                if (prefetchState && prefetchState.summaryP) {
                    try { summary = await prefetchState.summaryP; } catch(_) { summary = await fetchImpactSummary(isOcean); }
                } else {
                    summary = await fetchImpactSummary(isOcean);
                }
                if (summary) {
                    renderImpactSummary(summary);
                    renderEntryBlock(summary);
                    renderTargetBlock(summary);
                    populateAirBlast(summary);
                    populateSeismic(summary);
                    populateEjecta(summary);
                    drawImpactRings(lat, lon, summary);
                    await populateThermalImpactPopulation(lat, lon, summary);
                    populateThermalRanges(summary);
                }
            } catch(e) {
                addNote('impactErr', 'Impact API error: ' + String(e));
                setText('kEnv','—');
            }
        })();
    }
    function queueResize() {
        setTimeout(() => {
            const el = document.getElementById('globeViz');
            try {
                const w = el.clientWidth || window.innerWidth;
                const h = el.clientHeight || window.innerHeight;
                // Ask globe/gl renderer to fit container
                if (typeof globe.width === 'function') globe.width(w);
                if (typeof globe.height === 'function') globe.height(h);
                renderer.setSize(w, h, false);
                camera.aspect = w / h;
                camera.updateProjectionMatrix();
            } catch(e) {}
            window.dispatchEvent(new Event('resize'));
        }, 50);
    }
    function el(tag, props = {}, children = []) {
        const e = document.createElement(tag);
        Object.assign(e, props);
        try {
            if (props && props.attrs && typeof props.attrs === 'object') {
                for (const [k, v] of Object.entries(props.attrs)) {
                    if (v != null) e.setAttribute(k, String(v));
                }
            }
        } catch(_) {}
        children.forEach(c => e.appendChild(c));
        return e;
    }
    function txt(s) { return document.createTextNode(String(s)); }
    function setText(id, v) { const n = document.getElementById(id); if (n) n.textContent = v; }
    function addNote(id, message) { const n = document.getElementById(id); if (n) n.textContent = message; }
    function popKey(km) { try { return String(Number(km).toFixed(6)); } catch(e) { return String(km); } }

    // Lightweight, instant tooltip (no native delay)
    let instantTipEl = null;
    function ensureTipEl() {
        if (instantTipEl) return instantTipEl;
        const tip = document.createElement('div');
        tip.className = 'instant-tip';
        tip.style.position = 'fixed';
        tip.style.zIndex = '99999';
        tip.style.pointerEvents = 'none';
        tip.style.background = '#0b1220';
        tip.style.border = '1px solid #2a3b5f';
        tip.style.color = '#e6eefc';
        tip.style.padding = '6px 8px';
        tip.style.borderRadius = '6px';
        tip.style.fontSize = '12px';
        tip.style.maxWidth = '260px';
        tip.style.boxShadow = '0 6px 18px rgba(0,0,0,0.45)';
        tip.style.opacity = '0';
        tip.style.transform = 'translateY(-4px)';
        tip.style.transition = 'opacity 120ms ease, transform 120ms ease';
        document.body.appendChild(tip);
        instantTipEl = tip;
        return tip;
    }
    function positionTip(x, y) {
        const tip = ensureTipEl();
        const pad = 10;
        const vw = window.innerWidth;
        const vh = window.innerHeight;
        const rect = tip.getBoundingClientRect();
        let nx = Math.min(Math.max(0, x + pad), Math.max(0, vw - rect.width - 2));
        let ny = Math.min(Math.max(0, y + pad), Math.max(0, vh - rect.height - 2));
        tip.style.left = nx + 'px';
        tip.style.top = ny + 'px';
    }
    function showTip(text, x, y) {
        const tip = ensureTipEl();
        tip.textContent = text || '';
        positionTip(x, y);
        requestAnimationFrame(() => {
            tip.style.opacity = '1';
            tip.style.transform = 'translateY(0)';
        });
    }
    function hideTip() {
        if (!instantTipEl) return;
        instantTipEl.style.opacity = '0';
        instantTipEl.style.transform = 'translateY(-4px)';
    }
    function attachInstantTip(el, text) {
        if (!el) return;
        // Avoid native delay: remove title attribute if present
        try { if (el.hasAttribute('title')) el.removeAttribute('title'); } catch(_) {}
        const getText = () => text || el.getAttribute('data-tip') || '';
        const onEnter = (e) => showTip(getText(), e.clientX || 0, e.clientY || 0);
        const onMove = (e) => positionTip(e.clientX || 0, e.clientY || 0);
        const onLeave = () => hideTip();
        el.addEventListener('mouseenter', onEnter);
        el.addEventListener('mousemove', onMove);
        el.addEventListener('mouseleave', onLeave);
        // Keyboard accessibility
        el.addEventListener('focus', () => {
            const r = el.getBoundingClientRect();
            showTip(getText(), r.left + r.width / 2, r.top);
        });
        el.addEventListener('blur', hideTip);
        // Touch: tap to toggle briefly
        el.addEventListener('touchstart', (e) => {
            const t = (e.touches && e.touches[0]) || { clientX: 0, clientY: 0 };
            showTip(getText(), t.clientX, t.clientY);
            setTimeout(hideTip, 1600);
        }, { passive: true });
    }
    function startPrefetch(lat, lon) {
        try {
            prefetchState.lat = Number(lat);
            prefetchState.lon = Number(lon);
            prefetchState.popPromises = new Map();
            prefetchState.isOceanP = fetchIsOcean(prefetchState.lat, prefetchState.lon).catch(()=>false);
            prefetchState.summaryP = prefetchState.isOceanP
                .then(isOcean => fetchImpactSummary(isOcean))
                .then(summary => {
                    try {
                        // Pre-warm thermal ring populations
                        const r = (summary && summary.thermal && summary.thermal.ring_distances_km) || {};
                        const third = Number(r.third_degree_burn);
                        const second = Number(r.second_degree_burn);
                        const first = Number(r.first_degree_burn);
                        const desired = [third, second, first]
                            .filter(x => Number.isFinite(x) && x > 0)
                            .sort((a,b) => a - b);
                        for (const km of desired) {
                            const k = popKey(km);
                            if (!prefetchState.popPromises.has(k)) {
                                // Store the live promise; do not coerce failures to 0 here.
                                prefetchState.popPromises.set(k, fetchPopulation(prefetchState.lat, prefetchState.lon, km));
                            }
                        }
                    } catch(e) {}
                    return summary;
                })
                .catch(e => { /* swallow; UI handles errors */ return null; });
        } catch(e) { /* ignore */ }
    }
    function buildHeader(lat, lon) {
        const h = el('div');
        h.appendChild(el('h2', { innerText: 'Impact Report' }));
        h.appendChild(el('div', { className: 'meta', innerText: `Lat ${lat.toFixed(4)}, Lon ${lon.toFixed(4)}` }));
        return h;
    }
    function buildKpiGrid() {
        const wrap = el('div');
        // Helper to create an info badge with instant tooltip
        const mkInfo = (text) => {
            const b = el('span', { className: 'info-badge', innerText: 'i', attrs: { 'data-tip': text, tabindex: 0 } });
            attachInstantTip(b, text);
            return b;
        };

        const envWrap = el('span', { className: 'with-info' });
        const envTip = 'Classifies the impact point as Land or Ocean based on its location.';
        const envVal = el('span', { id:'kEnv', innerText: '…', attrs: { 'data-tip': envTip, tabindex: 0 } });
        attachInstantTip(envVal, envTip);
        envWrap.appendChild(envVal);
        envWrap.appendChild(mkInfo(envTip));
        wrap.appendChild(card('Environment', envWrap));
        const energyWrap = el('span', { className: 'with-info' });
        const tipText = "Hiroshima equivalents use 'Little Boy' ≈ 15 kt (kilotons TNT).";
        const energyVal = el('span', { id:'kEnergy', innerText: '…', attrs: { 'data-tip': tipText, tabindex: 0 } });
        const infoBadge = el('span', { className: 'info-badge', innerText: 'i', attrs: { 'data-tip': tipText, tabindex: 0 } });
        attachInstantTip(energyVal, tipText);
        attachInstantTip(infoBadge, tipText);
        energyWrap.appendChild(energyVal);
        energyWrap.appendChild(infoBadge);
        wrap.appendChild(card('Kinetic energy (TNT eq.)', energyWrap));
        const craterDTip = 'Final crater diameter from the impact model (km). Also drawn on the globe.';
        const craterDWrap = el('span', { className: 'with-info' });
        const craterDVal = el('span', { id:'kCrater', innerText: '…', attrs: { 'data-tip': craterDTip, tabindex: 0 } });
        attachInstantTip(craterDVal, craterDTip);
        craterDWrap.appendChild(craterDVal);
        craterDWrap.appendChild(mkInfo(craterDTip));
        wrap.appendChild(card('Crater diameter (km)', craterDWrap));

        const craterDepthTip = "Final crater depth from the impact model (meters). 'Eiffel towers' uses 300 m per tower.";
        const craterDepthWrap = el('span', { className: 'with-info' });
        const craterDepthVal = el('span', { id:'kCraterDepth', innerText: '…', attrs: { 'data-tip': craterDepthTip, tabindex: 0 } });
        attachInstantTip(craterDepthVal, craterDepthTip);
        craterDepthWrap.appendChild(craterDepthVal);
        craterDepthWrap.appendChild(mkInfo(craterDepthTip));
        wrap.appendChild(card('Crater depth (m)', craterDepthWrap));

        const tsunamiTip = 'Estimated coastal wave amplitude for ocean impacts. Shows collapse-wave at coast when applicable. Assumes depth ~3682 m, 100 km to coast, slope 0.005.';
        const tsunamiWrap = el('span', { className: 'with-info' });
        const tsunamiVal = el('span', { id:'kTsunami', innerText: '—', attrs: { 'data-tip': tsunamiTip, tabindex: 0 } });
        attachInstantTip(tsunamiVal, tsunamiTip);
        tsunamiWrap.appendChild(tsunamiVal);
        tsunamiWrap.appendChild(mkInfo(tsunamiTip));
        wrap.appendChild(card('Tsunami', tsunamiWrap));
        return wrap;
    }
    function card(title, valueNode) {
        const c = el('div', { className: 'item' });
        const r1 = el('div', { className: 't', innerText: title });
        const r2 = el('div', { className: 'v' }); r2.appendChild(valueNode);
        c.appendChild(r1); c.appendChild(r2);
        return c;
    }
    function buildImpactSections() {
        const wrap = el('div');
        // Keep only thermal population list and API ranges; omit verbose impact summary text blocks
        wrap.appendChild(el('div', { id: 'impactErr', className: 'meta', innerText: '' }));
        // Tip: circles on hover
        wrap.appendChild(el('div', { className: 'meta', innerText: 'Tip: hover rows to draw circles on the globe.' }));
        // Thermal sections first
        const tipThermPop = 'Population within thermal-damage rings: cumulative gridded population (2020), differenced into non-overlapping rings.';
        const hThermPop = el('h2', { innerText: 'Thermal impact population' });
        const hThermPopInfo = el('span', { className: 'info-badge', innerText: 'i', attrs: { 'data-tip': tipThermPop, tabindex: 0 } });
        attachInstantTip(hThermPopInfo, tipThermPop);
        hThermPop.appendChild(el('span', { innerText: ' ' }));
        hThermPop.appendChild(hThermPopInfo);
        wrap.appendChild(hThermPop);
        const tlistTop = el('div', { id: 'thermalPopList' });
        tlistTop.appendChild(el('div', { className: 'meta', innerText: 'loading…' }));
        wrap.appendChild(tlistTop);
        const tipThermRanges = 'Ignition thresholds (km) from the impact model: clothes, plywood, grass, paper, trees.';
        const hThermRanges = el('h2', { innerText: 'Thermal ranges' });
        const hThermRangesInfo = el('span', { className: 'info-badge', innerText: 'i', attrs: { 'data-tip': tipThermRanges, tabindex: 0 } });
        attachInstantTip(hThermRangesInfo, tipThermRanges);
        hThermRanges.appendChild(el('span', { innerText: ' ' }));
        hThermRanges.appendChild(hThermRangesInfo);
        wrap.appendChild(hThermRanges);
        const rlistTop = el('div', { id: 'thermalRangesList' });
        rlistTop.appendChild(el('div', { className: 'meta', innerText: 'loading…' }));
        wrap.appendChild(rlistTop);
        // Meteor details
        wrap.appendChild(el('h2', { innerText: 'Meteor' }));
        const mlist = el('div', { id: 'meteorDetails', className: 'list' });
        wrap.appendChild(mlist);
        // Entry
        wrap.appendChild(el('h2', { innerText: 'Entry' }));
        const entryList = el('div', { id: 'entryList', className: 'list' });
        wrap.appendChild(entryList);
        // Target
        wrap.appendChild(el('h2', { innerText: 'Target' }));
        const targetList = el('div', { id: 'targetList', className: 'list' });
        wrap.appendChild(targetList);
        // Air blast
        wrap.appendChild(el('h2', { innerText: 'Air blast' }));
        const airList = el('div', { id: 'airBlastList', className: 'list' });
        wrap.appendChild(airList);
        // Seismic activity
        wrap.appendChild(el('h2', { innerText: 'Seismic activity' }));
        const seisList = el('div', { id: 'seismicList', className: 'list' });
        wrap.appendChild(seisList);
        // Ejecta deposit
        wrap.appendChild(el('h2', { innerText: 'Ejecta deposit' }));
        const ejList = el('div', { id: 'ejectaList', className: 'list' });
        wrap.appendChild(ejList);
        return wrap;
    }

    function renderMeteorDetails() {
        try {
            const box = document.getElementById('meteorDetails');
            if (!box) return;
            box.innerHTML = '';
            const p = projectileFromContext();
            const d_m = Number(p.diameter_m) || 0;
            const d_km = d_m / 1000.0;
            const v_kps = (Number(p.speed_mps) || 0) / 1000.0;
            const rho = Number(p.density_kgpm3) || 0;
            const ang = Number(p.angle_deg) || 0;
            // mass
            let mass = 0;
            try { const r = d_m/2; const vol = (4/3)*Math.PI*r*r*r; mass = vol * rho; } catch(_) {}
            const rows = [
                ['Diameter', d_m > 0 ? `${d_m.toFixed(0)} m (${d_km.toFixed(3)} km)` : '—'],
                ['Speed', v_kps > 0 ? `${v_kps.toFixed(2)} km/s` : '—'],
                ['Density', rho > 0 ? `${nf(rho)} kg/m³` : '—'],
                ['Entry angle', ang > 0 ? `${ang.toFixed(0)}°` : '—'],
                ['Mass', mass > 0 ? `${nf(mass)} kg` : '—'],
            ];
            for (const [k, v] of rows) {
                const row = el('div', { className: 'item' });
                row.appendChild(el('div', { className: 'row' }, [
                    el('div', { className: 't', innerText: k }),
                    el('div', { className: 'v', innerText: v })
                ]));
                box.appendChild(row);
            }
        } catch(e) {}
    }

    // crater UI removed per requirements

    function projectileFromContext() {
        try {
            const raw = localStorage.getItem('terv_ctx');
            let d_m = 0, v_kps = 0, rho = 3000, angle = 45;
            if (raw) {
                const ctx = JSON.parse(raw);
                const sa = ctx?.selectedAsteroid;
                if (sa) {
                    const d_avg_km = ((sa.diameter_km_min ?? 0) + (sa.diameter_km_max ?? 0)) / 2;
                    d_m = Math.max(1, d_avg_km * 1000);
                    v_kps = Number(sa.vel_kps) || 17;
                }
            }
            if (!d_m) d_m = 680; // sensible fallback
            if (!v_kps) v_kps = 17;
            return { diameter_m: d_m, speed_mps: v_kps*1000, density_kgpm3: rho, angle_deg: angle };
        } catch(e) {
            return { diameter_m: 680, speed_mps: 17000, density_kgpm3: 3000, angle_deg: 45 };
        }
    }
    async function fetchImpactSummary(isOcean) {
        const projectile = projectileFromContext();
        const body = {
            projectile,
            target: { kind: isOcean ? 'water' : 'crystalline' },
            options: { luminous_efficiency: 3e-3, tsunami_depth_m: 3682.0, tsunami_distance_km: 100.0, tsunami_slope_ratio: 0.005 }
        };
        const bases = apiBases();
        const errs = [];
        for (const b of bases) {
            try {
                const res = await fetch(b + '/impact/summary', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(body) });
                if (!res.ok) throw new Error(String(res.status));
                return await res.json();
            } catch(e) { errs.push(`${b}: ${e}`); }
        }
        throw new Error('All backends failed: ' + errs.join(' | '));
    }
    function fmtKm(x) {
        if (x == null || isNaN(Number(x))) return '—';
        const v = Number(x);
        if (v > 0 && v < 0.01) return '< 0.01 km';
        return v.toFixed(2) + ' km';
    }
    function fmtMt(x) { return x == null ? '—' : Number(x).toFixed(2) + ' Mt TNT'; }
    function formatTntEqFromMt(mt) {
        if (mt == null || isNaN(mt)) return '—';
        const x = Number(mt);
        if (x >= 1) return x.toFixed(2) + ' Mt';
        const kt = x * 1e3;
        if (kt >= 1) return kt.toFixed(2) + ' kt';
        const t = x * 1e6;
        if (t >= 1) return t.toFixed(2) + ' t';
        const kg = x * 1e9;
        if (kg >= 1) return kg.toFixed(2) + ' kg';
        return '< 1 kg';
    }
    function renderImpactSummary(s) {
        // Only update KPI cards; omit verbose text outputs
        try {
            const E = s.energy || {};
            const J = E.kinetic_J;
            let Mt = E.tnt_megatons;
            if ((Mt == null || isNaN(Number(Mt))) && J != null && !isNaN(Number(J))) {
                Mt = Number(J) / 4.184e15;
            }
            const kt = (Number(Mt) || 0) * 1000.0;
            const hiro = kt / 15.0; // Little Boy ≈ 15 kt
            let hiroTxt = '';
            if (isFinite(hiro) && hiro > 0) {
                const val = hiro >= 100 ? nf(hiro) : hiro.toFixed(1);
                hiroTxt = ` (${val} Hiroshima)`;
            }
            setText('kEnergy', `${formatTntEqFromMt(Mt)}${hiroTxt}`);
        } catch(e) {}
        try {
            const C = s.crater || {};
            const Dfr_km = (C.final_diameter_m || 0)/1000.0;
            if (Dfr_km > 0) {
                const fields = (Dfr_km * 1000.0) / 109.7; // football field = 109.7 m
                setText('kCrater', `${Dfr_km.toFixed(2)} km (${fields.toFixed(1)} football fields)`);
            } else {
                setText('kCrater', '—');
            }
            const d_m = Number(C.final_depth_m);
            if (d_m && d_m > 0) {
                const towers = d_m / 300.0; // Eiffel tower ~300 m
                setText('kCraterDepth', `${Number(d_m).toFixed(0)} m (${towers.toFixed(1)} Eiffel towers)`);
            } else {
                setText('kCraterDepth', '—');
            }
        } catch(e) {}
        try {
            if (!envIsOcean) {
                setText('kTsunami', '—');
            } else {
                const T = s.tsunami || {};
                // Prefer collapse wave amplitude at the coast per requirements
                let h = (T.collapse_wave_amp_at_coast_m != null && !isNaN(Number(T.collapse_wave_amp_at_coast_m)))
                    ? Number(T.collapse_wave_amp_at_coast_m)
                    : null;
                // Fallbacks if collapse wave is not applicable for given conditions
                if (h == null) {
                    if (T.rim_wave_amp_at_coast_m != null && !isNaN(Number(T.rim_wave_amp_at_coast_m))) {
                        h = Number(T.rim_wave_amp_at_coast_m);
                    } else if (T.deep_amplitude_m != null && !isNaN(Number(T.deep_amplitude_m))) {
                        h = Number(T.deep_amplitude_m);
                    }
                }
                setText('kTsunami', h != null ? h.toFixed(2) : '—');
            }
        } catch(e) {}
    }

    function fmtM(x) { return (x==null || isNaN(Number(x))) ? '—' : `${Number(x).toFixed(0)} m`; }
    function fmtDb(x) { return (x==null || isNaN(Number(x))) ? '—' : `${Number(x).toFixed(1)} dB`; }
    function fmtDurSeconds(x) {
        if (x == null || isNaN(Number(x))) return '—';
        const sec = Math.max(0, Math.floor(Number(x)));
        if (sec >= 3600) {
            const h = Math.floor(sec / 3600);
            const m = Math.floor((sec % 3600) / 60);
            return m > 0 ? `${h} h ${m} m` : `${h} h`;
        }
        if (sec >= 60) {
            const m = Math.floor(sec / 60);
            const s = sec % 60;
            return s > 0 ? `${m} m ${s} s` : `${m} m`;
        }
        return `${sec} s`;
    }

    function renderEntryBlock(s) {
        const box = document.getElementById('entryList'); if (!box) return; box.innerHTML = '';
        try {
            const e = s.entry || {};
            const modeRaw = (e.mode || '').toString();
            const modeNice = modeRaw === 'surface_impact' ? 'Surface impact' : (modeRaw === 'airburst' ? 'Airburst' : (modeRaw ? modeRaw : '—'));
            const rows = [
                ['Mode', modeNice],
                ['Breakup altitude', e.breakup_altitude_m != null ? fmtM(e.breakup_altitude_m) : '—'],
            ];
            // Only show airburst altitude if actually an airburst
            if (modeRaw === 'airburst' && e.airburst_altitude_m != null) {
                rows.push(['Airburst altitude', fmtM(e.airburst_altitude_m)]);
            }
            for (const [k,v] of rows) {
                const row = el('div', { className:'item' });
                row.appendChild(el('div', { className:'row' }, [el('div',{className:'t',innerText:k}), el('div',{className:'v',innerText:v})]));
                if (k === 'Fatal radius' && Number.isFinite(Number(a.fatal_radius_km)) && a.fatal_radius_km > 0) {
                    const km = Number(a.fatal_radius_km);
                    row.addEventListener('mouseenter', () => {
                        try { if (currentImpact) showHoverCircle(currentImpact.lon, currentImpact.lat, km, STEPS_HOVER); } catch(_) {}
                    });
                    row.addEventListener('mouseleave', () => { try { clearHoverCircle(); } catch(_) {} });
                }
                box.appendChild(row);
            }
        } catch(e) {}
    }

    function renderTargetBlock(s) {
        const box = document.getElementById('targetList'); if (!box) return; box.innerHTML = '';
        try {
            const t = s.target || {};
            const rows = [
                ['Kind', t.kind || '—'],
                ['Density', t.density_kgpm3 != null ? `${nf(t.density_kgpm3)} kg/m³` : '—'],
                ['Gravity', t.gravity_mps2 != null ? `${Number(t.gravity_mps2).toFixed(2)} m/s²` : '—'],
            ];
            for (const [k,v] of rows) {
                const row = el('div', { className:'item' });
                row.appendChild(el('div', { className:'row' }, [el('div',{className:'t',innerText:k}), el('div',{className:'v',innerText:v})]));
                box.appendChild(row);
            }
        } catch(e) {}
    }

    function populateAirBlast(summary) {
        const box = document.getElementById('airBlastList'); if (!box) return; box.innerHTML='';
        try {
            const a = summary.air_blast || {};
            const rows = [
                ['Fatal radius', a.fatal_radius_km != null ? fmtKm(a.fatal_radius_km) : '—'],
                ['SPL at 1 km', fmtDb(a.spl_at_1km_db)],
            ];
            for (const [k,v] of rows) {
                const row = el('div', { className:'item' });
                row.appendChild(el('div', { className:'row' }, [el('div',{className:'t',innerText:k}), el('div',{className:'v',innerText:v})]));
                box.appendChild(row);
            }
            // Scaled radii (each as its own row)
            const h = a.health_rings_km || {};
            const t4 = a.table4_rings_km || {};
            const wind = a.wind_rings_km || {};
            const labelize = (k) => {
                if (!k) return '';
                if (k === 'severe_lung_damage') return 'Severe lung damage';
                if (k === 'eardrum_rupture') return 'Eardrum rupture';
                if (k === 'buildings_collapse') return 'Buildings collapse';
                if (k === 'homes_collapse') return 'Homes collapse';
                if (k === 'glass_shatter') return 'Glass shatter';
                return k.replace(/_/g, ' ').replace(/\b\w/g, c => c.toUpperCase());
            };
            const pushRow = (name, val) => {
                if (val == null) return;
                const row = el('div', { className: 'item' });
                row.appendChild(el('div', { className: 'row' }, [
                    el('div', { className: 't', innerText: name }),
                    el('div', { className: 'v', innerText: fmtKm(val) })
                ]));
                // Hover overlay circle on globe for this threshold
                try {
                    const km = Number(val);
                    if (Number.isFinite(km) && km > 0) {
                        row.addEventListener('mouseenter', () => {
                            try { if (currentImpact) showHoverCircle(currentImpact.lon, currentImpact.lat, km, STEPS_HOVER); } catch(_) {}
                        });
                        row.addEventListener('mouseleave', () => { try { clearHoverCircle(); } catch(_) {} });
                    }
                } catch(_) {}
                box.appendChild(row);
            };
            Object.entries(h).forEach(([k, v]) => pushRow(labelize(k), v));
            Object.entries(t4).forEach(([k, v]) => pushRow(labelize(k), v));
            Object.entries(wind).forEach(([k, v]) => pushRow(labelize(k), v));
        } catch(e) {}
    }

    function populateSeismic(summary) {
        const box = document.getElementById('seismicList'); if (!box) return; box.innerHTML='';
        try {
            const s = summary.seismic || {};
            const rows = [
                ['Source magnitude (M)', s.source_magnitude_M != null ? Number(s.source_magnitude_M).toFixed(2) : '—'],
                ['M6 radius', s.radius_km_M6 != null ? fmtKm(s.radius_km_M6) : '—'],
                ['M5 radius', s.radius_km_M5 != null ? fmtKm(s.radius_km_M5) : '—'],
                ['Felt radius', s.felt_radius_km != null ? fmtKm(s.felt_radius_km) : '—'],
            ];
            for (const [k,v] of rows) {
                const row = el('div', { className:'item' });
                row.appendChild(el('div', { className:'row' }, [el('div',{className:'t',innerText:k}), el('div',{className:'v',innerText:v})]));
                box.appendChild(row);
            }
        } catch(e) {}
    }

    function populateEjecta(summary) {
        const box = document.getElementById('ejectaList'); if (!box) return; box.innerHTML='';
        try {
            const e = summary.ejecta || {};
            const rows = [
                ['Rim height', e.rim_height_m != null ? fmtM(e.rim_height_m) : '—'],
                ['Fireball limit', e.fireball_limit_km != null ? fmtKm(e.fireball_limit_km) : '—'],
            ];
            for (const [k,v] of rows) {
                const row = el('div', { className:'item' });
                row.appendChild(el('div', { className:'row' }, [el('div',{className:'t',innerText:k}), el('div',{className:'v',innerText:v})]));
                box.appendChild(row);
            }
            const samples = Array.isArray(e.samples) ? e.samples.slice().sort((a,b)=> (a.r_km||0) - (b.r_km||0)).slice(0, 12) : [];
            if (samples.length) {
                const wrap = el('div', { className: 'item' });
                // Header
                wrap.appendChild(el('div', { className: 't', innerText: 'Samples' }));
                // Table-like grid
                const grid = el('div');
                grid.style.display = 'grid';
                grid.style.gridTemplateColumns = 'minmax(90px,1fr) minmax(90px,1fr) minmax(90px,1fr)';
                grid.style.columnGap = '10px';
                grid.style.rowGap = '6px';
                // Head row
                const h1 = el('div', { className: 't', innerText: 'Radius' });
                const h2 = el('div', { className: 't', innerText: 'Thickness' });
                const h3 = el('div', { className: 't', innerText: 'Arrival' });
                grid.appendChild(h1); grid.appendChild(h2); grid.appendChild(h3);
                // Rows
                for (const s of samples) {
                    const r = el('div', { innerText: fmtKm(s.r_km) });
                    const th = el('div', { innerText: (s.thickness_m!=null?fmtM(s.thickness_m):'—') });
                    const ar = el('div', { innerText: (s.arrival_s!=null? fmtDurSeconds(s.arrival_s):'—') });
                    grid.appendChild(r); grid.appendChild(th); grid.appendChild(ar);
                }
                wrap.appendChild(grid);
                box.appendChild(wrap);
            }
        } catch(e) {}
    }

    function drawImpactRings(lat, lon, s) {
        try {
            const now = Date.now();
            const addRing = (km, color, life=40000, speed=0.05) => {
                if (!km || km<=0) return;
                const deg = km / 111.0;
                rings.push({ lat, lng: lon, maxR: deg, propagationSpeed: speed, repeatPeriod: 1e9, color, createdAt: now, lifetime: life });
                ringsDirty = true;
            };
            // crater
            const C = s.crater || {};
            if (C.final_diameter_m && C.final_diameter_m>0) addRing((C.final_diameter_m/1000)/2, 'rgba(255,255,255,0.9)', 25000);
            // STATIC thermal circles: DEAD (third-degree), second-degree, first-degree
            const r = (s.thermal && s.thermal.ring_distances_km) || {};
            const feats = [];
            let craterRadiusKm = 0;

            // Always show a crater circle (final diameter)
            try {
                const crater_km = (C.final_diameter_m || 0) / 1000.0;
                if (crater_km > 0) {
                    craterRadiusKm = crater_km / 2;
                    const depth_m = Number((C.final_depth_m != null) ? C.final_depth_m : 0);
                    const depth_txt = (depth_m && depth_m > 0) ? `, depth \u2248 ${Number(depth_m).toFixed(0)} m` : '';
                    // Fill disk for crater area
                    const propsFill = envIsOcean
                      ? { fill: 'rgba(255,0,255,0.35)', stroke: '#ff00ff', alt: 0.050, label: `Crater diameter ≈ ${crater_km.toFixed(2)} km${depth_txt}` }
                      : { fill: 'rgba(255,255,255,0.12)', stroke: '#ffffff', alt: 0.018, label: `Crater diameter ≈ ${crater_km.toFixed(2)} km${depth_txt}` };
                    const craterFill = circleFeature(lon, lat, craterRadiusKm, STEPS_POLY, propsFill);
                    if (craterFill) feats.push(craterFill);
                    // Visible rim annulus (thickness ~2% of radius, min 0.6 km)
                    const rimThick = Math.max(0.6, craterRadiusKm * 0.02);
                    const rimLabel = `Crater diameter ≈ ${crater_km.toFixed(2)} km${depth_txt}`;
                    const propsRim = envIsOcean
                      ? { fill: 'rgba(255,0,255,0.95)', stroke: '#ff00ff', alt: 0.060, label: rimLabel }
                      : { fill: 'rgba(255,255,255,0.95)', stroke: '#ffffff', alt: 0.022, label: rimLabel };
                    const craterRimBand = annulusFeature(lon, lat, craterRadiusKm, rimThick, STEPS_POLY, propsRim);
                    if (craterRimBand) feats.push(craterRimBand);
                }
            } catch(e) {}
            // Ocean impacts: skip land thermal overlays; keep crater polygon and add a bright rim and static ring for visibility
            if (envIsOcean) {
                burnPolys = feats;
                burnPolysDirty = true;
                try { if (craterRadiusKm > 0) setCraterRimCircle(lon, lat, craterRadiusKm, 0xff00ff); } catch(_) {}
                return;
            }
            const red = circleFeature(
                lon, lat, Number(r.third_degree_burn), STEPS_POLY,
                { fill: 'rgba(255,0,0,0.22)', stroke: '#ff0000', alt: 0.010, label: 'DEAD (third-degree burns)' }
            );
            const orange = circleFeature(
                lon, lat, Number(r.second_degree_burn), STEPS_POLY,
                { fill: 'rgba(255,165,0,0.20)', stroke: '#ffa500', alt: 0.010, label: 'Second-degree burns' }
            );
            const yellow = circleFeature(
                lon, lat, Number(r.first_degree_burn), STEPS_POLY,
                { fill: 'rgba(255,255,0,0.18)', stroke: '#ffff00', alt: 0.010, label: 'First-degree burns' }
            );
            if (red) feats.push(red);
            if (orange) feats.push(orange);
            if (yellow) feats.push(yellow);
            burnPolys = feats;
            burnPolysDirty = true;
            // Add a subtle rim on land as well
            try { if (craterRadiusKm > 0) { setCraterRimCircle(lon, lat, craterRadiusKm, 0xffffff); } } catch(_) {}
        } catch(e) {}
    }

    // --- Thermal impact population (from API rings; non-overlapping; ordered by km) ---
    function nf(x) { return new Intl.NumberFormat('en-US').format(Math.round(Number(x)||0)); }
    async function populateThermalImpactPopulation(lat, lon, summary) {
        const list = document.getElementById('thermalPopList');
        if (!list) return;
        list.innerHTML = '';
        if (envIsOcean) {
            list.appendChild(el('div', { className: 'meta', innerText: 'poor fish :(' }));
            return;
        }
        try {
            const r = (summary && summary.thermal && summary.thermal.ring_distances_km) || {};
            const third = Number(r.third_degree_burn);
            const second = Number(r.second_degree_burn);
            const first = Number(r.first_degree_burn);
            // Use desired categories but keep strictly increasing radii only
            const desired = [
                { key: 'dead', label: 'DEAD', km: third },
                { key: 'burn2', label: 'Second-degree injuries', km: second },
                { key: 'burn1', label: 'First-degree injuries', km: first },
            ]
            .filter(x => Number.isFinite(x.km) && x.km > 0)
            .sort((a,b) => a.km - b.km);
            const ringsKm = [];
            for (const d of desired) {
                if (ringsKm.length === 0 || d.km > ringsKm[ringsKm.length-1].km) {
                    ringsKm.push(d);
                }
            }

            if (!ringsKm.length) {
                list.appendChild(el('div', { className: 'meta', innerText: 'No thermal ring distances available from API.' }));
                return;
            }

            // Build rows in km order
            for (const d of ringsKm) {
                const row = el('div', { className: 'item', id: `therm-${d.key}` });
                let label = d.label;
                // Add range context for non-innermost items later when we know prev
                row.appendChild(el('div', { className: 'row' }, [
                    el('div', { id: `therm-lbl-${d.key}`, innerText: `${label}` }),
                    el('div', { id: `therm-val-${d.key}`, innerText: 'loading…' })
                ]));
                list.appendChild(row);
            }

            // Fetch cumulative populations and compute non-overlapping annuli
            let prevCum = 0;
            let prevKm = 0;
            for (let i = 0; i < ringsKm.length; i++) {
                const d = ringsKm[i];
                try {
                    const cum = await getPopulationCached(lat, lon, d.km);
                    const inc = Math.max(0, cum - prevCum);
                    const label = i === 0
                        ? `${d.label} (<= ${fmtKm(d.km)})`
                        : `${d.label} (${fmtKm(prevKm)} – ${fmtKm(d.km)})`;
                    setText(`therm-lbl-${d.key}`, label);
                    setText(`therm-val-${d.key}`, nf(inc));
                    prevCum = cum;
                    prevKm = d.km;
                } catch (e) {
                    setText(`therm-val-${d.key}`, 'error');
                }
            }
        } catch(e) {
            list.appendChild(el('div', { className: 'meta', innerText: 'Error building thermal population list.' }));
        }
    }

    // --- Thermal ignite ranges (from API; ordered by km; no population counts) ---
    function populateThermalRanges(summary) {
        const list = document.getElementById('thermalRangesList');
        if (!list) return;
        list.innerHTML = '';
        if (envIsOcean) {
            list.appendChild(el('div', { className: 'meta', innerText: 'poor fish :(' }));
            return;
        }
        try {
            const r = (summary && summary.thermal && summary.thermal.ring_distances_km) || {};
            const items = [
                { key: 'clothes', label: 'Clothes ignite', km: r.clothes_ignite },
                { key: 'plywood', label: 'Plywood ignite', km: r.plywood_ignite },
                { key: 'grass', label: 'Grass ignite', km: r.grass_ignite },
                { key: 'paper', label: 'Newspaper ignite', km: r.newspaper_ignite },
                { key: 'trees', label: 'Trees ignite', km: r.trees_ignite },
            ]
            .filter(x => Number.isFinite(Number(x.km)) && Number(x.km) > 0)
            .map(x => ({ ...x, km: Number(x.km) }))
            .sort((a,b) => a.km - b.km);

            if (!items.length) {
                list.appendChild(el('div', { className: 'meta', innerText: 'No ignite thresholds available from API.' }));
                return;
            }

            for (const it of items) {
                const row = el('div', { className: 'item' });
                row.appendChild(el('div', { className: 'row' }, [
                    el('div', { innerText: it.label }),
                    el('div', { innerText: fmtKm(it.km) })
                ]));
                // Hover overlay on globe (line loop on top)
                row.addEventListener('mouseenter', () => {
                    try {
                        if (!currentImpact) return;
                        showHoverCircle(currentImpact.lon, currentImpact.lat, it.km, STEPS_HOVER);
                    } catch(e) {}
                });
                row.addEventListener('mouseleave', () => {
                    try { clearHoverCircle(); } catch(e) {}
                });
                list.appendChild(row);
            }
        } catch(e) {
            list.appendChild(el('div', { className: 'meta', innerText: 'Error reading ignite thresholds.' }));
        }
    }
    // Population-by-ring UI removed per requirements
    function apiBases() {
        // API lives on localhost:8080
        const proto = window.location.protocol || 'http:';
        return [`${proto}//localhost:8080`];
    }
    async function fetchJSON(path, params) {
        const qs = params ? ('?' + new URLSearchParams(params).toString()) : '';
        const errs = [];
        for (const b of apiBases()) {
            try {
                const res = await fetch(b + path + qs);
                if (!res.ok) throw new Error(String(res.status));
                return await res.json();
            } catch (e) { errs.push(`${b}: ${e}`); }
        }
        throw new Error('All backends failed: ' + errs.join(' | '));
    }
    async function fetchIsOcean(lat, lon) {
        const data = await fetchJSON('/isOcean', { lat, lon });
        return !!data; // api returns boolean
    }
    async function fetchPopulation(lat, lon, radius) {
        const data = await fetchJSON('/getPopulation', {
            lat, lon, radius,
            year: 2020, dataset: 'wpgppop'
        });
        return Number(data.population) || 0;
    }
    async function getPopulationCached(lat, lon, radius) {
        try {
            if (prefetchState && prefetchState.lat != null && prefetchState.lon != null) {
                const same = Math.abs(Number(lat) - Number(prefetchState.lat)) < 1e-6 && Math.abs(Number(lon) - Number(prefetchState.lon)) < 1e-6;
                if (same) {
                    const k = popKey(radius);
                    const p = prefetchState.popPromises && prefetchState.popPromises.get(k);
                    if (p) {
                        try { return await p; }
                        catch(_) {
                            // fallback: refetch once if prefetch failed
                            const fresh = fetchPopulation(lat, lon, radius);
                            try { prefetchState.popPromises.set(k, fresh); } catch(e) {}
                            return await fresh;
                        }
                    }
                }
            }
        } catch(e) {}
        return await fetchPopulation(lat, lon, radius);
    }
    // computeImpactModelKpis removed to ensure data is sourced from API
    // fetchRingsPopulation removed per requirements
</script>
<!-- end body -->
</body>
</html>
